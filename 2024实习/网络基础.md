
## ARP协议

地址解析协议，即ARP（Address Resolution Protocol），是根据ip地址获取物理地址的一个TCP/IP协议

**工作过程：**
1.发送arp请求的以太网数据帧广播到以太网上的每个主机，arp请求证包含了目的主机的IP地址
2.目的主机收到该arp请求后，会发送一个aro应答，里面包含了目的主机的MAC地址

**ARP协议工作原理：**
每个主机都会在自己的arp缓冲区建立一个arp列表，表示ip地址和MAC地址之间的对应关系。
主机（网络接口）新加入网络时（可能是MAC地址发生变化或者网络接口重启）会发送arp报文将自己的ip地址和MAC地址的映射关系广播给其他主机。

>发送arp数据包：
某个主机要发送报文时，首先会检测arp列表中是否有对应的ip地址与主机的MAC地址，如果有，则直接发送数据，如果没有会更新自己的arp缓冲区，将新的映射关系加入到arp列表中。

>收到arp数据包
（1）首先检查arp数据包中的ip地址是否是自己的ip地址，如果不是则直接忽略
（2）如果是自己的ip地址，则将源主机的ip和MAc地址写入自己的arp列表中，如果存在则覆盖
（3）将自己的MAC地址写入arp响应包中

源主机收到目标机的arp响应后，将目标机的ip地址与MAC地址写入arp列表，并利用此信息去发送数据。
如果源主机一直没有收到arp响应数据包，表示arp查询失败。
arp高速缓存（即arp列表）时arp协议能够高速运行的关键。

## RARP

反向地址转换协议，网络层协议。
与ARP工作方式相反，
RARP使只知道自己硬件的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。

原理：
（1）主机从网卡上读取mac地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的ip地址
（2）RARP服务器收到改RARP的请求数据包，为他分配IP地址，并将RARP回应发送给主机
（3）PC收到RARP回应后，就用得到的IP地址进行通信

## DNS

将主机域名转换为 ip 地址，属于应用层协议，使用 UDP 传输。


总结： 浏览器缓存，系统缓存，路由器缓存，IPS 服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

一、主机向本地域名服务器的查询一般是采用递归查询
二、本地域名服务器向根域名服务器的查询是迭代查询

（1）当用户输入域名是，浏览器先检查自己的缓存中是否有这个域名的ip地址，有解析则结束。
（2）若没命中，则请求操作系统缓存（如Windows的hosts文件）中有没有解析结果，有解析结束
（3）若没命中，则请求本地域名服务器解析（LDNS）
（4）若LDNS没有命中，就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个主域名服务器地址。
（5）此时LDNS再发送请求给上一步返回的gTLD（通用顶级域），接受请求的gTLD查找并返回这个域名对应的Nameserver地址
（6）Name server根据映射关系找到目标ip，返回给LDNS
（7）LDNS缓存这个域名和对应的ip，把解析的结果返回给用户，用户根据TTL指缓存到本地系统缓存中，域名解析过程到此结束

## RIP

RIP动态路由选择协议（网络层协议）
RIP 是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量来衡量到达目的网络的路由距离。RIP 通过 UDP 报文进行路由信息的交换，使用的端口号为 520。

RIP 路由协议用“更新（UNPDATES）”和“请求（REQUESTS）”这两种分组来传输信息的。
每个具有RIP协议功能的路由器每个30秒用UDP520端口给与之直接连接的机器广播信息。并且用“路程段数”（即“跳数”）作为网络距离的尺度。每个路由器在给相邻路由器发出路由信息时，都会给每个路径上加上内部距离。

任何距离向量路由选择协议（如 RIP）都有一个问题，路由器不知道网络的全局情况，路由器必须依靠相邻路由器来获取网络的可达信息。由于路由选择更新信息在网络上传播慢，距离向量路由选择算法有一个慢收敛问题，这个问题将导致不一致性产生。

RIP 较少路由收敛机制带来的问题：
1）记数到无穷大机制： RIP 协议允许最大跳数为 15。大于 15 的目的地被认为是不可达。当路径的跳数超过 15，这条路径才从路由表中删除。
2）水平分割法：路由器不向路径到来的方向回传此路径。当打开路由器接口后，路由器记录路径是从哪个接口来的，并且不向此接口回传此路径。
3）破坏逆转的水平分割法： 忽略在更新过程中从一个路由器获取的路径又传回该路由器
4）保持定时器法：防止路由器在路径从路由表中删除后一定的时间内（通常为 180 秒）接受新的路由信息。保证每个路由器都收到了路径不可达信息
5）触发更新法：当某个路径的跳数改变了，路由器立即发出更新信息，不管路由器是否到达常规信息更新时间都发出更新信息。

RIP 的缺点
1、由于 15 跳为最大值，RIP 只能应用于小规模网络；
2、收敛速度慢；
3、根据跳数选择的路由，不一定是最优路由。


## OSPF协议

Open Shortest Pass First,开放最短路径优先协议，是一个最常用的内部网管协议，是一个链路状态协议。(网络层协议)

原理：
OSPF 组播的方式在所有开启 OSPF 的接口发送 Hello 包，用来确定是否有 OSPF 邻居，若发现了，则建立 OSPF 邻居关系，形成邻居表，之后互相发送 LSA（链路状态通告）相互通告路由，形成 LSDB（链路状态数据库）。再通过 SPF 算法，计算最佳路径（cost 最小）后放入路由表。

## TCP与UDP的区别

1. TCP 面向连接（如打电话要先拨号建立连接）提供可靠的服务;UDP 是无连接的，即发送数据之前不需要建立连接，;UDP 尽最大努力交付，即不保证可靠交付。（由于 UDP 无需建立连接，因此 UDP 不会引入建立连接的时延，TCP 需要在端系统中维护连接状态，比如接受和发送缓存，拥塞控制，序号与确认号的参数等，故 TCP 会比 UDP 慢）
2. udp具有较好的实时性，工作效率比tcp高，适用于对告诉传输和实时性有较高的通信或广播通信。
3. 每一条 TCP 连接只能是一对一的;UDP 支持一对一，一对多，多对一和多对多的交互通信
4. UDP 分组首部开销小，TCP 首部开销 20 字节;UDP 的首部开销小，只有 8 个字节。
5. TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流;UDP 是面向报文的（一次交付一个完整的报文，报文不可分割，报文是 UDP 数据报处理的最小单位）。
6. UDP 适合一次性传输较小数据的网络应用，如 DNS，SNMP 等

### 什么是三次握手四次挥手？tcp 为什么要三次握手？
为了防止已失效的连接请求报文又传到了服务端，因而产生错误

**三次握手：**
1. 建立连接时，客户端发送syn包(`syn=j`)到服务器，并且进入SYN_SEND状态，等待服务器确认；
2. 服务器收到syn包。必须确认客户的SYN(`ack=j+1`)，同时自己也发送一个SYN包(`syn=k`)，即SYN+ACK包，此时服务器进入SYN_RECV状态；
3. 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(`ack=k+1`)，此包发送完毕，客户端和服务端进入 ESTABLISHED 状态，完成三次握手

***四次挥手**

客户端先发送FIN，进入FIN_WAIT1状态，用来关闭Client到Sever的数据传送
服务端收到FIN，发送ACK，进入CLOSE_WAIT状态，客户端收到这个ACK，进入FIN_WAIT2状态
服务端发送FIN，进入LAST_ACK状态用来关闭Server到Client的数据传送
客户端收到FIN，发送ACK，进入TIME_WAIT状态，服务端收到ACK，进入CLOSE状态（等待2MSL时间，约四分钟。主要是防止最后一个ACK丢失）

1. 主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我不会再发数据了，（在FIN包发送去之前的数据，如果没有收到对应的ack确认报文，主动关闭方依旧会重发这些数据），但是，此时主动关闭方还可以接受数据
2. 被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与syn相同，一个FIN占用一个序号）
3. 被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会给你发数据了
4. 主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此完成四次挥手


## GET 和 POST 的区别

get 是获取数据，post 是修改数据
get 把请求的数据放在 url 上， 以?分割 URL 和传输数据，参数之间以&相连，所以 get 不太安全。而 post 把数据放在 HTTP 的包体内（requrest body）
get 提交的数据最大是 2k（ 限制实际上取决于浏览器）， post 理论上没有限制。
GET 产生一个 TCP 数据包，浏览器会把 http header 和 data 一并发送出去，服务器响应 200(返回数据); POST 产生两个 TCP 数据包，浏览器先发送 header，服务器应 100 continue，浏览器再发送 data，服务器响应 200 ok(返回数据)。
GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置。

## Cookies 和 session 区别
Cookie 和 Session 都是客户端与服务器之间保持状态的解决方案

1. 存储的位置不同，cookie：存放在客户端，session：存放在服务端。session存储的数据比较安全
2. 存储的数据类型不同，两者都是key-value的结构，但针对value的类型是有差异的
cookie：value只能说字符串类型，session:value是Object类型
3. 存储的数据大小限制不同
cookie：大小受浏览器的限制，很多是4k的大小，session：理论上受当前内存的限制
4. 生命周期的控制
cookie的生命周期是累积的，从创建时，就开始计时，20分钟后，cookie生命周期结束，二十分钟内即使关闭浏览器还会有效
session的生命周期是间隔的，从创建时，就开始计时，没有访问session，那么session生命周期被销毁，关闭浏览器就销毁了

session的工作原理

客户端登陆完成后，服务器会创建对应的session，session创建完后，会把session的id发送给客户端，客户端在存储到浏览器中。客户端访问浏览器时，都会带着sessionid，服务器拿到sessionid后，在内存中找到与之对应的session，这样就可以正常工作了。

## HTTPS和HTTP的区别

1. HTTP协议（超文本传输协议）传输的数据不加密，明文传输，https是使用SSL+HTTP协议构建的可加密传输、身份认证的网络协议，比http安全。
2. https协议需要申请ca证书使用
3. http和https是完全不同的连接方式，端口不一致，80/443

## OSI 的七层模型

物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输
数据链路层：接受来自物理层的位流格式的数据，并封装成帧，传送到上一层
网络层：将网络地址翻译成对应的物理地址，并通过路由算法为分组通过通信子网选择最适当的路径
传输层：在源段和目的端之间提供可靠的透明数据传输
会话层：负责在网络中的两节点之间建立、维持和终止通信
表示层：处理用户信息的表示问题，数据的编码、压缩、加解密等
应用层：为用户的应用程序提供网络通信服务

## TCP 如何保证可靠传输？

1. 三次握手
2. 将数据截断为合理的长度。应用数据被切割成tcp被认为是最适合发送的数据块（按字节编号，合理分片）
3. 超时重放。当tcp发出一个段后，他启动一个定时器，如果不能及时收到一个确认就重放
4. 确认应答。对于收到的请求会给出确认响应
5. 校验和。检验出包有错，丢弃报文段，不给响应
6. 序列号。对失序数据进行重新排序，然后再交给应用层
7. 丢弃重复数据。
8. 流量控制。TCP连接的每一方都有固定的流量缓存空间，接收方只允许另一端发送可接纳的流量数据。
9. 拥塞控制。当网络拥塞时，减少数据发送。

## 常见状态码
200 OK //客户端请求成功 403 Forbidden //服务器收到请求，但是拒绝提供服务
404 Not Found //请求资源不存在，eg：输入了错误的 URL
500 Internal Server Error //服务器发生不可预期的错误

## TCP 对应的应用层协议
FTP：定义了文件传输协议，使用 21 端口.
Telnet：它是一种用于远程登陆的端口,23 端口
SMTP：定义了简单邮件传送协议，服务器开放的是 25 号端口。
POP3：它是和 SMTP 对应，POP3 用于接收邮件。
HTTP
## UDP 对应的应用层协议
DNS：用于域名解析服务，用的是 53 号端口
SNMP：简单网络管理协议，使用 161 号端口
TFTP(Trival File Transfer Protocal)：简单文件传输协议，69

## 什么是同源策略？
为了防止不同域在用户浏览器中彼此干扰，浏览器对从不同来源（域）收到的内容进行隔离。
浏览器不允许任何旧有脚本访问一个站点的 cookie，否则，会话容易被劫持
只有发布 cookie 的站点能够访问这些 cookie，只有通过该站点返回的页面所包含或加载的 JavaScript 才能访问 cookie。